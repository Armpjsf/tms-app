[
  {
    "projectId": "51e621d9-742f-4418-9646-ce8dfd48ee02",
    "testId": "f774f456-84c7-4180-b874-b3bba9cd81a1",
    "userId": "f4786438-60d1-7030-46d1-b1ac9b0e3b51",
    "title": "TC001-Authentication success with valid credentials",
    "description": "Verify that a user can successfully log in using valid credentials and receive appropriate session tokens.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Attempt to reload the current page using the visible 'Reload' button to recover from ERR_EMPTY_RESPONSE. If reload succeeds, continue by locating the login form or session indicators; if it still fails, report the issue.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Wait briefly for the SPA to load, then navigate directly to the login page at /login to attempt to load the login form (use direct navigation only because the current page has no interactive elements).\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill phone and password fields on the login form and submit the form to attempt authentication and trigger a redirect to the dashboard.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/form/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('0812345678')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the login submit button to attempt authentication and then (after navigation) extract page content to search for session tokens (access_token, refresh_token, jwt, Authorization, Bearer, token, localStorage, session, user_id, userId, email).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        ```\n        try:\n            await expect(frame.locator('text=Dashboard').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test attempted to verify that a user logging in with valid credentials is redirected to the dashboard and a session is established (session tokens available). The page did not display 'Dashboard', so the login, redirect, or session creation likely failed.\")\n        ```\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Result: Login verification failed (success=false).\n\nSummary of attempts:\n- Navigation: /login loaded successfully (tab C4AE).\n- Credentials entered: phone '0812345678' (input index 1083), password 'password123' (input index 1091).\n- Submit attempts: submit button (index 1092) clicked twice; page remained on /login.\n- Visible page feedback: error message displayed - 'ไม่พบเบอร์โทรศัพท์นี้ในระบบ' (translation: phone number not found in the system).\n- No redirect to dashboard detected and no session tokens (localStorage/cookies/inline JSON) were observed on the page.\n\nConclusion:\n- The user cannot be logged in with the provided test credentials. Session tokens were not issued or are not accessible because authentication failed.\n\nRecommended next steps to achieve verification:\n1) Provide valid credentials known to the backend (correct phone number and password) and retry the login flow.\n2) If valid credentials are available but login still fails, check server/backend logs for authentication errors and verify the user exists in the system.\n3) If automated tests are required, add a Playwright test that:\n   - Navigates to /login\n   - Fills phone and password fields\n   - Clicks submit and waits for navigation to /dashboard (assert URL or dashboard-specific element)\n   - After redirect, assert presence of session token in localStorage or appropriate cookie (e.g., check localStorage.getItem('access_token') or cookie named 'access_token')\n4) If tokens are stored in a cookie with HttpOnly flags and not accessible to client-side scripts, confirm backend sets expected cookie headers and test at API/request level.\n\nIf updated/valid test credentials are provided, re-run the login attempt to verify successful authentication and token issuance.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4786438-60d1-7030-46d1-b1ac9b0e3b51/1770866682639722//tmp/test_task/result.webm",
    "created": "2026-02-12T03:19:38.073Z",
    "modified": "2026-02-12T03:24:42.821Z"
  },
  {
    "projectId": "51e621d9-742f-4418-9646-ce8dfd48ee02",
    "testId": "96199626-fa7f-479c-8f85-7fb85bab01ac",
    "userId": "f4786438-60d1-7030-46d1-b1ac9b0e3b51",
    "title": "TC002-Authentication failure with invalid credentials",
    "description": "Verify that the system rejects login attempts with invalid username or password and shows an error message.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4786438-60d1-7030-46d1-b1ac9b0e3b51/1770866528836067//tmp/test_task/result.webm",
    "created": "2026-02-12T03:19:38.078Z",
    "modified": "2026-02-12T03:22:08.945Z"
  },
  {
    "projectId": "51e621d9-742f-4418-9646-ce8dfd48ee02",
    "testId": "65af2788-76b9-4f50-b1e5-c8363ab176f1",
    "userId": "f4786438-60d1-7030-46d1-b1ac9b0e3b51",
    "title": "TC003-Role-based access control enforcement",
    "description": "Verify that users can only access features and pages according to their assigned roles and permissions.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the user/profile menu (to find logout or switch-account options) so the session can be changed to a limited-permission user.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/header/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the logout button in the sidebar (index 275) to sign out so a limited-permission user can be logged in.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the Reload button (index 74) to recover the application and get a fresh page state so login can be attempted.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Recover the application by reloading/navigating to the app URL to get a fresh page load so login can be attempted.\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4786438-60d1-7030-46d1-b1ac9b0e3b51/1770866656252439//tmp/test_task/result.webm",
    "created": "2026-02-12T03:19:38.083Z",
    "modified": "2026-02-12T03:24:16.464Z"
  },
  {
    "projectId": "51e621d9-742f-4418-9646-ce8dfd48ee02",
    "testId": "7e823073-6697-40dd-8e8f-9801743e9ed0",
    "userId": "f4786438-60d1-7030-46d1-b1ac9b0e3b51",
    "title": "TC004-Dashboard displays correct summary information",
    "description": "Verify that the dashboard accurately displays the daily tasks, vehicle statuses, and job statistics reflective of the system data.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the Reload button to attempt to recover the dashboard page (use interactive element index 74).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Reload the dashboard page to recover it so metrics can be re-extracted (navigate to http://localhost:3000/dashboard).\n        await page.goto(\"http://localhost:3000/dashboard\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the login page / perform login as an authorized user so dashboard data can be re-verified against backend data.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[2]/div/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Dashboard page by clicking the 'Dashboard' navigation link (element index 2093) so current visible dashboard labels/metrics can be extracted for verification.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[1]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Daily Tasks').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Expected the dashboard to display 'Daily Tasks' confirming daily tasks, vehicle statuses, and job statistics reflect backend data, but the expected header or metrics did not appear or were not visible\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Verification attempt summary and extracted dashboard metrics (UI-only). Backend comparison not performed because no backend data or access was provided.\n\nExtracted dashboard values (from current UI/screenshot):\nงานวันนี้: 1\nส่งสำเร็จ: 0\nSOS Alerts: 0\nรถ Active: 1\nคนขับ Active: 2\nกำลังจัดส่ง: 0\nรอดำเนินการ: 1\nรถใกล้ถึงกำหนดซ่อม: 0\nสถิติการจัดส่งรายสัปดาห์: (chart present; no single numeric summary extracted) \nสัดส่วนสถานะงาน: New 0 (no other status slices with numeric labels visible)\n\nConclusion: UI shows the metrics above. Verification versus system/backend data could not be completed due to lack of backend access or expected values. To complete verification, provide one of the following:\n- Backend API endpoint(s) and credentials or a dataset/file with the expected metric values for today; or\n- The expected numeric values for the listed labels so a direct comparison can be made.\n\nNext options available on request:\n- Provide backend access/expected values and request re-run of verification (will compare UI values above to backend and report matches/mismatches).\n- Request generation of Playwright tests for: Login, Dashboard access, and Excel Import on Drivers page (provide desired test details such as test account or upload file path if needed).\n\nSuccess=false because backend verification was not possible.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4786438-60d1-7030-46d1-b1ac9b0e3b51/1770866817620998//tmp/test_task/result.webm",
    "created": "2026-02-12T03:19:38.088Z",
    "modified": "2026-02-12T03:26:57.754Z"
  },
  {
    "projectId": "51e621d9-742f-4418-9646-ce8dfd48ee02",
    "testId": "e82d84b2-f855-4a74-ab7e-301f0070c5d4",
    "userId": "f4786438-60d1-7030-46d1-b1ac9b0e3b51",
    "title": "TC005-Driver profile CRUD operations",
    "description": "Verify that user can create, read, update, and delete driver profiles through the UI.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the Drivers management page from the dashboard navigation (click the Drivers link in the sidebar).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[2]/div/a[7]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Attempt to recover the dashboard by clicking the Reload button on the browser error page. If reload fails, look for alternative navigation or report site unavailable.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Reload the dashboard by navigating to http://localhost:3000/dashboard to attempt to recover the app and restore interactive elements.\n        await page.goto(\"http://localhost:3000/dashboard\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the Drivers management page by clicking the Drivers link in the dashboard sidebar.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[2]/div/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Navigate to the Drivers management page (open /drivers). If that loads, locate the Create button to begin CRUD flow.\n        await page.goto(\"http://localhost:3000/drivers\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the Create (เพิ่มคนขับ) driver form by clicking the 'เพิ่มคนขับ' (Add driver) button on the Drivers page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[1]/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Create Driver form by clicking the 'เพิ่มคนขับ' (Add Driver) button so the new driver can be entered.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[1]/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the Create Driver form with valid test data and submit the form (click the 'เพิ่มคนขับ' submit button) to create the new driver.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[5]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('E2E-DRV-001')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[5]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('E2E Test Driver')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[5]/form/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('0999999001')\n        \n        # -> Fill the Password field in the Add Driver form and submit the form to create the new driver (then verify the driver appears in the list).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[4]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[4]/form/div[6]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Reload /drivers and verify that the new driver (Driver_ID = 'E2E-DRV-001', Driver_Name = 'E2E Test Driver', Mobile_No = '0999999001') appears in the drivers list with correct information.\n        await page.goto(\"http://localhost:3000/drivers?page=1\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Search the drivers list for 'E2E-DRV-001' using the page search input and submit the search to locate the created driver.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[3]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('E2E-DRV-001')\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=E2E-DRV-001').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: the test attempted to verify that the newly created driver with ID 'E2E-DRV-001' appears in the drivers list after creation, but the expected entry was not found — driver creation or list refresh likely failed.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Summary of CRUD verification attempt (result: INCOMPLETE)\n\nWhat was attempted:\n- Navigated to Drivers management page.\n- Opened Add Driver form and filled with: Driver_ID='E2E-DRV-001', Driver_Name='E2E Test Driver', Mobile_No='0999999001', Password='password123'.\n- Submitted the Add Driver form once.\n- Navigated/reloaded Drivers list and used the page search for 'E2E-DRV-001'.\n\nObserved outcome:\n- Search input contains 'E2E-DRV-001' and page displays 'ไม่พบข้อมูลคนขับ' (no driver data). No row for E2E-DRV-001 was found.\n- The UI shows an existing driver (example URT-001) but the newly created record is not present.\n- This indicates the create action did not result in a visible new record in the UI. Possible causes: server-side creation failure, client-side rendering/refresh issue after submission, or validation prevented creation.\n\nDetailed results / evidence:\n- Create form was filled and submitted once (values shown above).\n- Search for 'E2E-DRV-001' returned no results.\n- Drivers page currently shows 'ไม่พบข้อมูลคนขับ' for that query.\n\nConclusion:\n- CRUD flows cannot be fully verified because the Create -> Read step failed to show the created driver. Therefore Update and Delete could not be attempted or verified.\n\nRecommended next steps to continue verification:\n1) Check the application/network/backend logs or API responses for the create (POST) request to confirm whether the server accepted the create request and whether it returned success or an error. Capture the API response/body and any validation messages.\n2) If API shows success, investigate client-side state refresh: ensure the UI refreshes the drivers list after successful creation; check console for JS errors and ensure the frontend receives/uses the response.\n3) If API shows an error (validation, conflict, or server error), fix data or backend and retry creation. Try a different unique Driver_ID (e.g., E2E-DRV-002) to rule out conflicts.\n4) After a successful create confirmed by API, re-run the UI flow: search for the new driver, then perform Update and Delete and verify each operation in the UI and via API responses.\n5) Once UI flow reliably works, generate Playwright tests for: Login, Dashboard access, and Drivers Excel Import, and add an end-to-end test for Create->Read->Update->Delete of a test driver.\n\nCurrent status: Task incomplete. Creation not verifiable; full CRUD not confirmed.\n\nIf continued automation is desired, grant permission to: (A) re-attempt creation with a new unique ID, (B) open browser console/network logs and capture API responses, or (C) run the follow-up steps above and retry CRUD flows.\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4786438-60d1-7030-46d1-b1ac9b0e3b51/1770866938498916//tmp/test_task/result.webm",
    "created": "2026-02-12T03:19:38.092Z",
    "modified": "2026-02-12T03:28:58.618Z"
  },
  {
    "projectId": "51e621d9-742f-4418-9646-ce8dfd48ee02",
    "testId": "114cfe4e-8110-4531-8de1-5dd7f4283dda",
    "userId": "f4786438-60d1-7030-46d1-b1ac9b0e3b51",
    "title": "TC006-Bulk import drivers via Excel with valid data",
    "description": "Verify that bulk import of driver data using an Excel file imports all valid records and updates the system correctly.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Retry loading the dashboard by clicking the Reload button on the error page to recover the site before continuing to the Drivers page and the import flow.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Drivers management page by using the dashboard search input (enter 'คนขับ' — Thai for 'drivers') and submit the search to reveal the Drivers page link.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/header/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('คนขับ')\n        \n        # -> Click the 'คนขับ' (Drivers) link in the sidebar to open the Drivers management page (element index 138).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[3]/div/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Drivers management page and wait for the page to load so the bulk import controls are visible. Then proceed to initiate the bulk import.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[3]/div/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Import Excel dialog by clicking the 'นำเข้า Excel' (Import Excel) button (element index 1892) to begin the bulk import flow.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[1]/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Upload a well-formed Excel file using the file input (index 2219) then click the Import button (index 2232) to start the bulk import.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4786438-60d1-7030-46d1-b1ac9b0e3b51/1770866744063986//tmp/test_task/result.webm",
    "created": "2026-02-12T03:19:38.097Z",
    "modified": "2026-02-12T03:25:44.169Z"
  },
  {
    "projectId": "51e621d9-742f-4418-9646-ce8dfd48ee02",
    "testId": "7681c51e-3984-4e5c-b0ac-e079cdceb10f",
    "userId": "f4786438-60d1-7030-46d1-b1ac9b0e3b51",
    "title": "TC007-Bulk import drivers via Excel with malformed data",
    "description": "Verify the system handles invalid or corrupted Excel files gracefully and provides relevant error messages during bulk import of drivers.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Drivers' (Drivers management) navigation link on the dashboard to open the Drivers page so the bulk import UI can be accessed.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[3]/div/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Reload' button (index 74) to attempt to restore the dashboard so the Drivers link can be accessed.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Drivers' (คนขับ) navigation link to open the Drivers management page and access the bulk import UI.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[3]/div/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Drivers' (คนขับ) navigation link to open the Drivers management page and access the bulk import UI.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[3]/div/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Drivers' navigation element (use element index 1218) to open the Drivers management page and access the bulk import UI.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[3]/div/a[3]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the bulk import dialog by clicking the 'นำเข้า Excel' (Import Excel) button so the file upload input appears (element index 3289).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[1]/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Upload a corrupted/invalid Excel file using the file input (index 3544), then click the import/submit button to trigger validation and observe any error messages (click index 3557).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Create an invalid/corrupted Excel file, upload it using the file input (index 3544), click the import button (index 3557), wait for processing, and extract any visible error/validation messages shown by the UI.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4786438-60d1-7030-46d1-b1ac9b0e3b51/1770866800021355//tmp/test_task/result.webm",
    "created": "2026-02-12T03:19:38.102Z",
    "modified": "2026-02-12T03:26:40.270Z"
  },
  {
    "projectId": "51e621d9-742f-4418-9646-ce8dfd48ee02",
    "testId": "cd9037fe-2039-48f9-8f21-ea92b345ebb7",
    "userId": "f4786438-60d1-7030-46d1-b1ac9b0e3b51",
    "title": "TC008-Vehicle profile CRUD operations",
    "description": "Verify creating, reading, updating, and deleting vehicle profiles with status tracking and maintenance alert settings.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the navigation element that leads to the Vehicles (vehicle management) page from the dashboard.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[2]/div/a[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the Reload button (index 74) to attempt reloading the dashboard so navigation links (Vehicles) become available.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the navigation element that leads to the Vehicles (vehicle management) page from the dashboard.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[2]/div[4]/div/div[3]/div[1]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Reload the application by navigating to the root URL (http://localhost:3000) to restore the SPA DOM; then re-check for the Vehicles navigation link.\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the navigation element that leads to the Vehicles (vehicle management) page from the dashboard.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/header/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Vehicles management page by clicking the 'รถ' (Vehicles) navigation link and verify the Vehicles list loads.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[3]/div/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'รถ' (Vehicles) navigation link (index 2232) to open the Vehicles management page and verify the Vehicles list loads.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[3]/div/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the 'เพิ่มรถใหม่' (Add New Vehicle) form by clicking the Add New Vehicle button (index 3906) so the vehicle creation form can be filled.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[1]/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the 'เพิ่มรถใหม่' (Add New Vehicle) form by clicking the Add New Vehicle button (index 3906) and wait for the form to appear so form inputs can be filled.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[1]/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the Add New Vehicle form with test data (registration 'TEST-1234', brand 'Toyota', model 'Hilux Revo', current mileage 200000, next service mileage 210000, vehicle type '4 ล้อ (4-Wheel)') and submit. Then verify the new vehicle appears in the vehicles list.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TEST-1234')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Toyota')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Hilux Revo')\n        \n        # -> Fill current mileage with 200000 and next service mileage with 210000, then submit the Add New Vehicle form (click submit).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[3]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('200000')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[3]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('210000')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[4]/form/div[5]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Reload the application by navigating to http://localhost:3000 to restore the SPA DOM, wait for the page to load, then re-open Vehicles and verify the vehicle 'TEST-1234' appears.\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the Vehicles management page by clicking the 'รถ' (Vehicles) navigation link and then verify whether the vehicle with plate 'TEST-1234' appears in the list.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[3]/div/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Vehicles management page by clicking the 'รถ' (Vehicles) navigation link (index 5098), then locate/search for registration 'TEST-1234' to verify whether the vehicle exists.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[3]/div/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Enter 'TEST-1234' into the Vehicles search input and click the search button to locate the vehicle in the list and verify whether it exists.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/header/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TEST-1234')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/header/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Add New Vehicle form (modal) so the vehicle can be created again (or confirm form fields before submitting). Click the 'เพิ่มรถใหม่' (Add New Vehicle) button.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[1]/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the Add New Vehicle form with registration 'TEST-1234', brand 'Toyota', model 'Hilux Revo', current mileage '200000', next service mileage '210000' and then submit the form to create the vehicle (this is the second creation attempt).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[5]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TEST-1234')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[5]/form/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Toyota')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[5]/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Hilux Revo')\n        \n        # -> Navigate to http://localhost:3000 to reload the SPA DOM so the Vehicles page and interactive elements can be restored for continuing verification (then re-open Vehicles and proceed to submit/verify the vehicle).\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'รถ' (Vehicles) navigation link to open the Vehicles management page so the CRUD verification can continue (then search for plate 'TEST-1234').\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[3]/div/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4786438-60d1-7030-46d1-b1ac9b0e3b51/177086715136802//tmp/test_task/result.webm",
    "created": "2026-02-12T03:19:38.107Z",
    "modified": "2026-02-12T03:32:31.502Z"
  },
  {
    "projectId": "51e621d9-742f-4418-9646-ce8dfd48ee02",
    "testId": "0362ec8d-f9dc-45fe-b88a-6a5171127aed",
    "userId": "f4786438-60d1-7030-46d1-b1ac9b0e3b51",
    "title": "TC009-Bulk import vehicles via Excel with valid data",
    "description": "Verify successful import of multiple vehicles from a valid Excel spreadsheet updating vehicle fleet accurately.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Attempt to recover the page by clicking the Reload button to get the dashboard back online so navigation to Vehicles/Drivers can continue.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4786438-60d1-7030-46d1-b1ac9b0e3b51/1770866618047496//tmp/test_task/result.webm",
    "created": "2026-02-12T03:19:38.112Z",
    "modified": "2026-02-12T03:23:38.156Z"
  },
  {
    "projectId": "51e621d9-742f-4418-9646-ce8dfd48ee02",
    "testId": "1bb83ebb-52a3-4670-894e-21be185765f8",
    "userId": "f4786438-60d1-7030-46d1-b1ac9b0e3b51",
    "title": "TC010-Planning and job creation with VRP settings",
    "description": "Verify that jobs can be created and planned effectively using the configurable Vehicle Routing Problem (VRP) settings including vehicle types, job types, and time windows.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the Reload button (element index 74) to attempt to recover the dashboard, then re-locate and open the Planning page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'วางแผนงาน' (Planning) navigation link to open the Planning page (use element index 1113).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[2]/div/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'วางแผนงาน' (Planning) navigation link (index 1113) to open the Planning page, then wait 2 seconds for the page to load and verify Planning-specific UI elements.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[2]/div/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the job creation form by clicking the 'สร้างงานใหม่' (Create new job) button so new job entries can be added.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[1]/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill required job details (customer name and product type) in the 'ข้อมูลงาน' tab and click 'ถัดไป →' to proceed to the location step.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[5]/form/div[1]/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Customer')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[5]/form/div[1]/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Product')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[5]/form/div[2]/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill origin and destination location fields (name, latitude, longitude) in the Create Job modal and click 'ถัดไป →' to go to the 'มอบหมาย' (Assign/VRP) tab.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/div[1]/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Factory A')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/div[1]/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('13.756300')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/div[1]/div[2]/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('100.501800')\n        \n        # -> Fill destination location fields (name, latitude, longitude) in the Create Job modal and click 'ถัดไป →' to proceed to the Assign (มอบหมาย) tab.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/div[2]/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Customer Location')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/div[2]/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('13.745000')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/div[2]/div[2]/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('100.523000')\n        \n        # -> Click the 'ถัดไป →' (Next) button in the Create Job modal to go to the 'มอบหมาย' (Assign/VRP) tab, then configure VRP settings (vehicle types, job types, time windows).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[4]/form/div[2]/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Configure VRP assignment: choose vehicle registration and driver, then proceed by clicking 'ถัดไป →' to reach the Price tab.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[4]/form/div[2]/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'สร้างงาน' (Create job) button in the Create Job modal to submit the job.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Create Job modal again by clicking 'สร้างงานใหม่' so the job can be submitted (then proceed to submit and run optimization). Immediate action: click element index 2841 ('สร้างงานใหม่').\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[1]/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'สร้างงาน' (Create job) submit button in the Create Job modal to create the job (element index 3742).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[5]/form/div[2]/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the job detail for JOB-20260212-4555 to locate VRP/assignment/optimization controls (open job details to configure VRP and run optimization).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[3]/div/div[2]/div[1]/div/div[1]/div[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open JOB-20260212-4555 detail (if not already open), locate VRP/assignment/optimization controls (vehicle type selectors, time windows, assign/optimize buttons), and extract their visible labels/text for verification.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[3]/div/div[2]/div[1]/div/div[1]/div[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the JOB-20260212-4555 detail pane and extract all visible VRP / assignment / optimization controls and their labels/text so VRP configuration UI can be verified.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[3]/div/div[2]/div[1]/div/div[1]/div[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4786438-60d1-7030-46d1-b1ac9b0e3b51/1770867189829265//tmp/test_task/result.webm",
    "created": "2026-02-12T03:19:38.117Z",
    "modified": "2026-02-12T03:33:09.969Z"
  },
  {
    "projectId": "51e621d9-742f-4418-9646-ce8dfd48ee02",
    "testId": "46bcff01-4ce7-485f-976a-68270bbeb489",
    "userId": "f4786438-60d1-7030-46d1-b1ac9b0e3b51",
    "title": "TC011-Bulk import jobs via Excel",
    "description": "Verify that job records are successfully imported in bulk from Excel files and correctly processed in the system.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the likely navigation/menu button (index 252) to expand/reveal the Planning or Drivers link so it can be clicked.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/header/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the Planning navigation link to open the Planning/Drivers page (click element index 57).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[2]/div/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the Planning link again (index 57) to open the Planning/Drivers page and reveal the bulk import (Excel upload) controls.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[2]/div/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'นำเข้า Excel' (Import Excel) button to open the Excel upload dialog (element index 1889).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[1]/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'นำเข้า Excel' (Import Excel) button again (index 1889) to open the Excel upload dialog and reveal the file input for uploading an Excel file.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[1]/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Create a test Excel file, upload it via the file input (index 2122), click the import/confirm button (index 2135), wait for processing, then extract page content to verify that the job(s) from the file (e.g., 'Bulk Test Customer') appear in the job list.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        # Wait a short while for the import processing and job list to update\n        await page.wait_for_timeout(3000)\n        \n        # Read visible page text and assert imported job details are present\n        body_text = await page.locator('body').inner_text()\n        assert 'JOB-20260212-6643' in body_text, \"Imported job ID 'JOB-20260212-6643' not found on the page\"\n        assert 'Test Customer New' in body_text, \"Imported job customer 'Test Customer New' not found on the page\"\n        assert '2026-02-12' in body_text, \"Imported job date '2026-02-12' not found on the page\"\n        \n        # Optional: verify the dashboard summary reflects the new job\n        assert '1 งานวันนี้' in body_text or '1 งานวันนี้' in body_text.replace('\\n',' '), \"Dashboard summary for today's jobs does not show the expected count '1 งานวันนี้'\"\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4786438-60d1-7030-46d1-b1ac9b0e3b51/1770866749260383//tmp/test_task/result.webm",
    "created": "2026-02-12T03:19:38.122Z",
    "modified": "2026-02-12T03:25:49.422Z"
  },
  {
    "projectId": "51e621d9-742f-4418-9646-ce8dfd48ee02",
    "testId": "68dea924-995f-4058-8bea-d44c7a887225",
    "userId": "f4786438-60d1-7030-46d1-b1ac9b0e3b51",
    "title": "TC012-Handling invalid job data in bulk import",
    "description": "Verify that invalid or incomplete job entries in bulk Excel import are rejected or reported with clear errors without corrupting valid data entries.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the navigation/menu item that leads to the Planning or Drivers page (click a sidebar/nav button).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/header/div[2]/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the sidebar/navigation element that should open the Planning or Drivers page (attempt navigation to Planning/Drivers).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/header/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the page Reload button (index 74) to try to recover the dashboard and proceed with navigation to the Planning/Drivers page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4786438-60d1-7030-46d1-b1ac9b0e3b51/1770867113891715//tmp/test_task/result.webm",
    "created": "2026-02-12T03:19:38.127Z",
    "modified": "2026-02-12T03:31:54.010Z"
  },
  {
    "projectId": "51e621d9-742f-4418-9646-ce8dfd48ee02",
    "testId": "a40bcadf-75b4-4208-9f6b-c70fd72c2537",
    "userId": "f4786438-60d1-7030-46d1-b1ac9b0e3b51",
    "title": "TC013-Real-time GPS tracking map updates",
    "description": "Verify that the admin map interface displays real-time and accurate vehicle locations on Leaflet maps with frequent updates.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Retry loading the dashboard by clicking the Reload button on the error page\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Navigate to the login page to attempt an admin login (/login) since the dashboard SPA did not load; if login page is reachable, proceed with authentication steps.\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the phone and password fields on the login page and submit the form to attempt authentication (first login attempt). If login redirects, then locate the admin/dashboard navigation to open the GPS tracking map.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/form/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('0812345678')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Termination report — task not completed.\n\nSummary of attempts and results:\n- Objective: Verify admin map interface displays real-time and accurate vehicle locations on Leaflet maps (verify login/dashboard/map and real-time updates). Also generate Playwright tests for Login, Dashboard access, and Excel Import on Drivers page.\n\n- Attempted actions (chronological):\n  1) Opened http://localhost:3000/dashboard — result: ERR_EMPTY_RESPONSE (server did not send data). No SPA DOM loaded. (1 of 3 dashboard attempts used)\n  2) Clicked Reload on the browser error page (index 74) — attempt failed due to element not interactable/stale on first try.\n  3) Navigated to http://localhost:3000/login — page loaded (driver login screen available).\n  4) Filled login form: phone = '0812345678', password = 'password123', clicked submit — no navigation or success confirmation observed (likely driver login or server did not respond with a redirect). (1 of 3 login attempts used)\n  5) Attempted to navigate to http://localhost:3000/admin/login — navigation timed out / ERR_EMPTY_RESPONSE.\n  6) Clicked Reload button (index 74) again on the browser error page — timed out. Reload attempts exhausted (2 of 2 reload attempts used).\n\n- Current page state: Browser error page showing \"This page isn’t working — localhost didn’t send any data. ERR_EMPTY_RESPONSE\" with a Reload button (interactive element index 74). No application DOM, no Leaflet map, no vehicle markers or map controls available to inspect.\n\n- Playwright tests: None generated. Critical flows (Login, Dashboard access, Excel Import) could not be instrumented because the admin/dashboard routes and API were unreachable.\n\n- Why verification failed: The backend/webserver at http://localhost:3000 was not responding (ERR_EMPTY_RESPONSE) on the admin/dashboard and admin/login routes. Without a responsive server and the SPA DOM, the Leaflet map and vehicle data cannot be loaded or validated and real-time updates cannot be observed.\n\n- What remains to complete the task:\n  1) Ensure backend/webserver is started and responding at http://localhost:3000 (fix ERR_EMPTY_RESPONSE).\n  2) After server is up, navigate to admin login or dashboard, perform admin authentication, open the GPS tracking map, and verify vehicle markers and real-time updates. 3) Generate Playwright tests covering Login, Dashboard, and Excel Import flows.\n\n- Recommendations to unblock and retry:\n  - Start the backend process (API and web server) and confirm HTTP responses from http://localhost:3000 in a browser or with curl. Ensure no firewall or port conflict blocks localhost:3000.\n  - Confirm WebSocket or SSE endpoints used for real-time location updates are available and returning data.\n  - Provide working admin credentials or confirm that admin login route is /admin/login or accessible from /login.\n  - Once the server responds, re-run automated verification: navigate to admin login, log in as admin, open the GPS tracking map, assert initial vehicle markers are present, and simulate/observe tracking updates to confirm real-time marker updates. Then generate the requested Playwright test scripts.\n\nConclusion: The task could not be completed due to server unavailability (ERR_EMPTY_RESPONSE). No map verification or Playwright tests were produced. Retry after backend is started. Detailed attempt log and counts are included above.\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4786438-60d1-7030-46d1-b1ac9b0e3b51/1770867105767513//tmp/test_task/result.webm",
    "created": "2026-02-12T03:19:38.132Z",
    "modified": "2026-02-12T03:31:45.907Z"
  },
  {
    "projectId": "51e621d9-742f-4418-9646-ce8dfd48ee02",
    "testId": "a3e67caf-d0aa-40a5-9b50-931c07689fb8",
    "userId": "f4786438-60d1-7030-46d1-b1ac9b0e3b51",
    "title": "TC014-Job status update via Mobile PWA",
    "description": "Verify drivers can update job statuses from assigned tasks using the mobile PWA, and that status changes sync correctly to the backend.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the Reload button on the error page to retry loading the dashboard (interactive element index 74).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the main navigation/menu (click a top nav/menu button) to find the Drivers page or switch to mobile PWA view so the driver flows can be exercised.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/header/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the Drivers page link in the main navigation to open the Drivers list (or switch to mobile PWA view) so the driver flows can be exercised.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/header/div[2]/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4786438-60d1-7030-46d1-b1ac9b0e3b51/1770866660911993//tmp/test_task/result.webm",
    "created": "2026-02-12T03:19:38.138Z",
    "modified": "2026-02-12T03:24:21.025Z"
  },
  {
    "projectId": "51e621d9-742f-4418-9646-ce8dfd48ee02",
    "testId": "611f7cef-4d0c-4807-9984-d3b9578db4d9",
    "userId": "f4786438-60d1-7030-46d1-b1ac9b0e3b51",
    "title": "TC015-Offline support and sync for Mobile PWA job updates",
    "description": "Verify that Mobile PWA allows offline access to assigned jobs, enables status updates offline, and correctly syncs data when network is restored.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to the Assigned Jobs / Tracking page by clicking the left-nav 'ติดตาม' link so the assigned jobs list can be accessed.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[2]/div/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'ติดตาม' (Assigned/Tracking) link in the left navigation to open the Assigned Jobs page so offline checks can begin.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[2]/div/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'ติดตาม' (Assigned/Tracking) left-nav link (index 84) to open the Assigned Jobs page so offline checks can begin.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[2]/div/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Allow the SPA time to load, then navigate to the dashboard URL (http://localhost:3000/dashboard) to restore a loaded app view and continue with offline workflow checks.\n        await page.goto(\"http://localhost:3000/dashboard\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to the Assigned Jobs (Monitoring) page and extract the assigned jobs list so offline checks can start (then simulate going offline).\n        await page.goto(\"http://localhost:3000/monitoring\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the SPA by navigating to Dashboard then back to Monitoring to attempt to force the assigned-jobs list to render, then extract visible assigned jobs. If jobs appear, proceed with offline simulation; otherwise report inability to locate per-job DOM nodes and request backend/API access or test data to continue.\n        await page.goto(\"http://localhost:3000/dashboard\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:3000/monitoring\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Offline job updates synced').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Expected offline job updates to sync after network restoration. The test updated a job while offline, restored connectivity, and was expecting a visible 'Offline job updates synced' confirmation or the updated job status to appear, but no sync confirmation or updated status was found in the UI\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Unable to complete PWA offline verification: per-job DOM entries were not found on the Assigned Jobs (Monitoring) page, preventing offline-access, offline-update and sync tests. What was attempted: logged in (dashboard confirmed), navigated to /monitoring, clicked Assigned/Tracking link twice, performed three job-list extraction attempts (including after scrolling), and reloaded dashboard/monitoring to force render — all returned 'no jobs visible'. Observed issues: SPA navigation timeouts earlier, and the UI shows total_jobs:1 but no per-job DOM nodes. Blocking reason (objective): assigned-job UI elements are missing (likely lazy-load, SPA mount failure, or API not returning job items). Required to continue: provide test data (seed jobs) that appear in the UI, fix the SPA/API so job entries render, or provide the backend/test API endpoints to verify sync. Next steps available once UI shows jobs: 1) simulate offline (network offline), 2) open assigned job details and change status, 3) restore network, 4) verify backend received the update. If desired, a Playwright test file implementing these steps can be generated now (requires visible job DOM selectors or test data). Stopping as requested.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4786438-60d1-7030-46d1-b1ac9b0e3b51/1770866982820617//tmp/test_task/result.webm",
    "created": "2026-02-12T03:19:38.144Z",
    "modified": "2026-02-12T03:29:42.942Z"
  },
  {
    "projectId": "51e621d9-742f-4418-9646-ce8dfd48ee02",
    "testId": "feca767b-b84e-4222-b213-127a09e79c63",
    "userId": "f4786438-60d1-7030-46d1-b1ac9b0e3b51",
    "title": "TC016-Filtering and searching jobs and orders",
    "description": "Verify that users can effectively filter and search jobs and shipments based on criteria such as status, date range, vehicle, driver, and other parameters.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to the job/planning page by clicking the 'วางแผนงาน' (Planning) navigation link (index 61) to start applying filters and searches.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[2]/div/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Enter a job identifier into the search box (index 1329), submit the search, and extract the visible job list items to verify the results update according to the search/filter.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/header/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('JOB-20260212-6643')\n        \n        # -> Open the full job list (click 'ดูทั้งหมด') to reveal the full filtering UI so status, date range, vehicle, driver filters can be applied and verified.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[3]/div/div[1]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Apply a date range filter (set start and end date to 2026-02-12), trigger the filter/search, then extract visible job list entries to verify the list updates correctly for the date range.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[2]/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('2026-02-12')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[2]/div/div/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('2026-02-12')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[2]/div/div/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        ```\n        try:\n            await expect(frame.locator('text=JOB-20260212-6643').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Expected job 'JOB-20260212-6643' to appear in the filtered job/shipment list after applying the search and date range filters (and other criteria); the list did not update to show the expected result.\")\n        ```\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Summary of verification (partial):\n- Search by Job ID (JOB-20260212-6643): SUCCESS — job appears in results with job_id=JOB-20260212-6643, customer=Test Customer, status=ใหม่, date=2026-02-12.\n- Date range filter (2026-02-12 to 2026-02-12): SUCCESS — same job appears as expected.\n- Status filter (selected 'ล้มเหลว'): INCONCLUSIVE/FAILED — dropdown selection completed but job list did NOT update; extraction after applying the status shows the job still present with status 'ใหม่'. Possible causes: filters require an explicit \"Apply\" action, the status filter is additive with other active filters (e.g., Job ID or date), or a UI/backend bug preventing status-only filtering. \n- Vehicle, Driver, Additional parameter filters: NOT TESTED.\nConclusion: Filtering/search is partially verified (Job ID and date range work). Status filtering did not behave as expected in this run and requires further investigation. To fully verify filter functionality, run the remaining tests: clear other filters and re-apply status filter, then test vehicle and driver filters. Also verify if an explicit apply/search control is required after changing filter values.\nRecommended next steps to complete verification:\n1) Clear the search input and date filters, set Status='ล้มเหลว', trigger apply/search, then extract results. 2) Test vehicle filter by selecting a vehicle and extracting results. 3) Test driver filter similarly. 4) If filters still do not work, capture console/network logs and report issue to developers.\nResult: Task incomplete — not all filters verified and status filter behavior is inconclusive. Returning findings and stopping as requested.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4786438-60d1-7030-46d1-b1ac9b0e3b51/1770866816838694//tmp/test_task/result.webm",
    "created": "2026-02-12T03:19:38.148Z",
    "modified": "2026-02-12T03:26:56.957Z"
  },
  {
    "projectId": "51e621d9-742f-4418-9646-ce8dfd48ee02",
    "testId": "548180cb-1417-479e-ace3-116b8d3ac511",
    "userId": "f4786438-60d1-7030-46d1-b1ac9b0e3b51",
    "title": "TC017-Shipment assignment via tap menu",
    "description": "Verify users can assign jobs or shipments to vehicles through the tap menu and that assignment status updates correctly.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'วางแผนงาน' (Plan jobs) link to open the shipment/job assignment interface and load the assignment UI.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[2]/div/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'วางแผนงาน' (Plan jobs) link (index 61) to open the shipment/job assignment interface and load the assignment UI (then inspect for job list and tap/assign controls).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[2]/div/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Allow the SPA time to load; if DOM remains empty, reload the planning page to recover the app and then locate the assignment UI (job list and tap/assign controls).\n        await page.goto(\"http://localhost:3000/planning\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the job detail for JOB-20260212-6643 by clicking its job entry (element index 2469) to locate the tap menu and assignment controls.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[3]/div/div[2]/div/div/div[1]/div[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the job entry (index 2469) to open its detail panel and reveal the tap menu / assignment controls.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[3]/div/div[2]/div/div/div[1]/div[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open full job list by clicking 'ดูทั้งหมด' (View all) button (index 2460) to access the job detail without repeating the previous failing click.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[3]/div/div[1]/a/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the svg element inside the job row (index 2470) to open the tap menu or job detail and reveal assignment controls.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[3]/div/div[2]/div/div/div[1]/div[1]/svg').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the job detail for JOB-20260212-6643 from the Jobs History page to reveal the tap menu / assignment controls (click the job row/svg that opens the detail).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[4]/div[2]/div[1]/table/tbody/tr/td[2]/div/svg').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the job detail / tap-menu for JOB-20260212-6643 by clicking the job-row SVG control (index 3035) to reveal assignment controls.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[4]/div[2]/div[1]/table/tbody/tr/td[2]/div/svg').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the job detail/tap-menu for JOB-20260212-6643 by clicking the alternative svg control at index 3040 to reveal assignment controls.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[4]/div[2]/div[1]/table/tbody/tr/td[4]/div/svg').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the job's tap menu / detail for JOB-20260212-6643 by clicking the SVG control at index 3046 to reveal assignment controls (vehicle assignment).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[4]/div[2]/div[1]/table/tbody/tr/td[7]/span/svg').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the job's tap menu / detail for JOB-20260212-6643 to reveal assignment controls by clicking the job-row SVG control (index 3035). If the tap menu opens, locate and use the 'Assign to vehicle' option.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[4]/div[2]/div[1]/table/tbody/tr/td[2]/div/svg').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the job-row SVG control (index 3046) to attempt to open the tap menu / job detail and reveal the 'Assign to vehicle' option.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[4]/div[2]/div[1]/table/tbody/tr[2]/td[7]/span/svg').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the job-row SVG control at index 3040 to attempt to open the tap menu / job detail and reveal the 'Assign to vehicle' option.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[4]/div[2]/div[1]/table/tbody/tr[2]/td[4]/div/svg').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the job's tap-menu for JOB-20260212-6643 by clicking the job-row SVG control (index 3046) to reveal the 'Assign to vehicle' option and then inspect the DOM for the assignment control/menu.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[4]/div[2]/div[1]/table/tbody/tr[2]/td[7]/span/svg').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Assigned to vehicle').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: attempted to assign selected job(s) to a vehicle via the tap menu and verify the assignment appeared in the UI; expected 'Assigned to vehicle' confirmation but it did not appear — the assignment may not have been saved or the UI did not update\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Verification attempt summary and next steps:\n\nSummary of findings:\n- The Jobs History page (/jobs/history?page=1) is loaded and displays job rows with columns including Driver (คนขับ) and Plate (ทะเบียน). Some jobs show '-' under driver (unassigned) and one job shows a driver name.\n- No visible UI controls or menu items labelled with assignment-related keywords (English: 'Assign', 'Assign to vehicle', etc.; Thai: 'มอบหมาย', 'มอบหมายให้', 'ยานพาหนะ', etc.) were found in the current DOM snapshot or extracted content.\n- Multiple attempts were made to open job details/tap-menus (clicked job-row and several SVG controls at indices 2469, 2470, 3035, 3040, 3046). None produced a visible assignment menu or assignment UI. Several SPA routing/timeouts and intermittent empty-DOM events were observed during these attempts, which likely prevented the tap-menu from opening reliably.\n\nConclusion:\n- Cannot confirm that users can assign jobs/shipments to vehicles via the tap menu because the assignment controls were not found or did not open reliably in the current session. Verification of assignment status updates could not be completed.\n\nRecommended next steps to continue or recover the test:\n1) Retry in a fresh session/tab and reproduce the flow from Planning (วางแผนงาน) rather than Jobs History. This reduces SPA-state issues from prior failed navigations.\n2) Ensure the test user has sufficient permissions (Admin or Planner) that enable assignment controls — some UI elements may be hidden for read-only roles.\n3) On the Planning page, try clicking the job ID link (if present) instead of the surrounding row or SVG, or open each job via a dedicated 'Open' button (if present). Consider expanding the row or toggling any context menus that reveal more actions.\n4) If SPA timeouts persist, add a longer wait after navigation or perform a full page reload before interacting. If the app uses a sidebar router, use the sidebar 'วางแผนงาน' link to navigate and wait for the planning list to render fully.\n5) If assignment UI still not present, check server-side feature flags / environment (assignment feature may be disabled) or inspect console/network logs for errors.\n6) If required, provide a screenshot of the job row context or HTML snippet around the job-row elements for developer inspection.\n\nPlaywright tests: none were generated in this attempt. If requested, Playwright tests can be generated next for: (a) Login (email/password test credentials), (b) Dashboard navigation to Planning, (c) Open job detail and assert presence of assignment controls, (d) Assign job to vehicle and verify UI reflects assignment. Permission checks and longer timeouts should be included.\n\nBecause assignment controls could not be located and the verification could not be completed, this run ends with success=false. Provide guidance above to continue debugging or allow re-run with the suggested steps.\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4786438-60d1-7030-46d1-b1ac9b0e3b51/1770867040891302//tmp/test_task/result.webm",
    "created": "2026-02-12T03:19:38.153Z",
    "modified": "2026-02-12T03:30:41.012Z"
  },
  {
    "projectId": "51e621d9-742f-4418-9646-ce8dfd48ee02",
    "testId": "60d69b34-9db1-4d72-b568-8e95bf072345",
    "userId": "f4786438-60d1-7030-46d1-b1ac9b0e3b51",
    "title": "TC018-VRP routing parameter validations",
    "description": "Verify that the Vehicle Routing Problem configuration interface validates inputs for vehicle types, job types, time windows, and route preferences preventing invalid settings.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Use the dashboard search input to find 'VRP' and open the Vehicle Routing Problem configuration/settings page (search input index 254, search button index 256). Then proceed to input invalid/conflicting parameters and verify validations.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/header/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('VRP')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/header/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the system Settings page to locate Vehicle Routing Problem (VRP) configuration. Click the 'ตั้งค่า' (Settings) link (index 236) and then locate VRP configuration within settings.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Planning/VRP area by clicking the 'วางแผนงาน' (Planning) link (index 61) so the VRP configuration/settings can be located.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[2]/div/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the planning page search, search for 'VRP' using the search input on this page and click the search button to try to open the VRP configuration/settings page (use input index 1838 then click button index 1840).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/header/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('VRP')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/header/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the system Settings page to locate VRP configuration by clicking the 'ตั้งค่า' (Settings) link (index 1818) to navigate into settings.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the system Settings page to locate Vehicle Routing Problem (VRP) configuration by clicking the 'ตั้งค่า' (Settings) link (index 1818), then locate the VRP configuration section.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Search for 'VRP' in the Settings page using the search input (index 2895) and click the adjacent search button (index 2897) to open the VRP configuration section.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/header/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('VRP')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/header/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Trigger the Settings search (click button index 2897) to open the VRP configuration section so validation checks can be performed.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/header/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Planning area from the Settings left navigation to try locating the VRP configuration there. If Planning loads, search within Planning for VRP and open its configuration page to begin validation checks (access settings, input invalid params, verify validation).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[2]/div/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Planning area from the left navigation to try to locate the VRP configuration entry there (click the 'วางแผนงาน' nav link).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[2]/div/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Search for 'VRP' on the Planning page using the search input (index 3990) and click the adjacent search button (index 3992) to attempt to open the VRP configuration interface.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/header/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('VRP')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/header/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Settings page from the left navigation to locate the VRP configuration entry (click anchor index 3970).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the user/admin menu to find an alternative path to system settings or VRP configuration (click the Admin button/profile menu) and then look for VRP or System/Settings link.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/header/div[2]/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Planning area to search for and access the Vehicle Routing Problem (VRP) configuration (click 'วางแผนงาน' nav link).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[2]/div/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Use the header search input to search for 'VRP' (new search widget index 4544) and trigger the search (click button index 4567) to try to open the VRP configuration page.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/header/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('VRP')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/header/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open System Settings from the left nav to attempt to find VRP configuration entry (click Settings link). After Settings opens, locate the VRP settings entry and click to open the VRP configuration screen.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open System Settings from the left nav (click element index 4997) to attempt to locate the VRP configuration entry, then wait for the page to load.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Use the Settings search input (index 5991) to search for 'VRP' and trigger the search (button index 5993) to reveal the VRP configuration entry so it can be opened.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/header/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('VRP')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/header/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4786438-60d1-7030-46d1-b1ac9b0e3b51/1770867219751911//tmp/test_task/result.webm",
    "created": "2026-02-12T03:19:38.158Z",
    "modified": "2026-02-12T03:33:39.902Z"
  },
  {
    "projectId": "51e621d9-742f-4418-9646-ce8dfd48ee02",
    "testId": "e49411c4-cf77-42f6-9443-a8fa66c647c3",
    "userId": "f4786438-60d1-7030-46d1-b1ac9b0e3b51",
    "title": "TC019-UI responsiveness and accessibility compliance",
    "description": "Verify that all main pages including dashboard, drivers, vehicles, planning and maps render correctly on various screen sizes and support keyboard navigation and screen readers.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the navigation/menu to reveal links to other main pages so the tests can navigate to Drivers, Vehicles, Planning, and Maps (click nav/menu control).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/header/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Drivers page (desktop viewport) by clicking the 'คนขับ' / Drivers link in the left navigation.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[3]/div/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Try to navigate to the Drivers page by clicking the 'คนขับ' link in the left navigation again (element index 142).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[3]/div/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Attempt navigation to the Drivers page again by clicking the 'คนขับ' / Drivers link (element index 142).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[3]/div/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Navigate to Dashboard (desktop) by clicking the dashboard/home link (anchor index 1626) to load the Dashboard page on the current tab.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[1]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Navigate to Dashboard (desktop) by clicking the Dashboard link in the left navigation to load the Dashboard page on the current tab so layout and accessibility checks can begin on desktop.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[1]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Navigate to the Drivers page on the current tab (desktop viewport) and then run keyboard navigation + extract page headings and interactive elements for screen-reader verification.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[3]/div/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the Drivers ('คนขับ') link in the left navigation to load the Drivers page on the current tab (desktop viewport). After it loads, run keyboard navigation and extract headings + interactive elements for screen-reader verification.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[3]/div/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Navigate to Vehicles page (desktop viewport) by clicking the 'รถ' / Vehicles link in the left navigation and then perform keyboard navigation and extract main headings and interactive elements for screen-reader verification.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[3]/div/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the Vehicles ('รถ') link (index 4847) to load the Vehicles page on the current tab (desktop), wait for the page to load, run keyboard navigation (Tab x10), then extract main headings and all interactive elements (with ARIA/title/placeholder) and note any missing accessible labels or focus issues.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[3]/div/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the Vehicles link (index 4847) to load the Vehicles page on the current tab (desktop), then run keyboard navigation (Tab x10) and extract main headings and all interactive elements (buttons, links, inputs) including visible text and ARIA/title/placeholder attributes; note missing accessible labels or focus-state issues.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[3]/div/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Planning page (วางแผนงาน) using the left navigation link and load the Planning page on the current tab (desktop) so keyboard navigation and screen-reader extraction can be performed.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[2]/div/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the Planning link in the left navigation (index 6845) to load the Planning page on the current tab (desktop), wait for load, run keyboard navigation (Tab x10), then extract main headings (h1/h2/h3) and enumerate all interactive elements with visible text and ARIA/title/placeholder attributes and note missing labels or focus issues.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[2]/div/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the Planning link in the left navigation (index 6845) to load the Planning page on the current tab (desktop). After the page loads, run keyboard navigation (Tab x10) and extract main headings and interactive elements for screen-reader verification.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[2]/div/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Load the Planning page (วางแผนงาน) on the current tab (desktop), run keyboard navigation (Tab x10), then extract the main headings (h1/h2/h3) and list all interactive elements (buttons, links, inputs) with visible text and any ARIA/title/placeholder attributes for screen-reader verification.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[2]/div/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the Planning link in the left navigation (index 6845) to load the Planning page on the current tab (desktop). After the page loads, run keyboard navigation (Tab x10) and extract main headings (h1/h2/h3) and enumerate interactive elements with visible text and ARIA/title/placeholder attributes for screen-reader verification.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[2]/div/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the Planning link in the left navigation (index 6845) to load the Planning page on the current tab (desktop). After page loads, run keyboard navigation (Tab x10) and extract main headings and interactive elements for screen-reader verification (this extraction will be scheduled once page load is confirmed).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[2]/div/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Navigate to the Maps (ติดตาม) page on the current tab (desktop) by clicking the Maps link (index 6847). After it loads, perform keyboard navigation and extract headings + interactive elements for screen-reader verification (scheduled after load confirmation).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[2]/div/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> On the current tab: (1) load Maps page (click index 6847), perform keyboard navigation (Tab x10) and extract headings + interactive elements for screen-reader verification; (2) navigate to Planning using the search input (index 6986) to avoid repeated clicks on the Planning nav item, then perform keyboard navigation (Tab x10) and extract headings + interactive elements.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[2]/div/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4786438-60d1-7030-46d1-b1ac9b0e3b51/1770867277954093//tmp/test_task/result.webm",
    "created": "2026-02-12T03:19:38.163Z",
    "modified": "2026-02-12T03:34:38.103Z"
  },
  {
    "projectId": "51e621d9-742f-4418-9646-ce8dfd48ee02",
    "testId": "dc9b19d7-de46-430d-9acd-eaf46c0fffd7",
    "userId": "f4786438-60d1-7030-46d1-b1ac9b0e3b51",
    "title": "TC020-API input validation and error responses",
    "description": "Verify all API endpoints related to authentication, driver/vehicle/job management, routing, and tracking enforce strict input validation and return appropriate error responses for invalid or malicious inputs.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the Drivers page from the sidebar to locate the Excel Import controls (upload button / modal) so tests can target the import flow.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[3]/div/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'คนขับ' (Drivers) sidebar link to open the Drivers page and inspect the page for Excel Import controls (upload button / modal).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/div[3]/div/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'นำเข้า Excel' (Import Excel) button on the Drivers page to open the Excel import UI/modal and inspect for upload file input and modal controls.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[1]/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4786438-60d1-7030-46d1-b1ac9b0e3b51/1770867150993105//tmp/test_task/result.webm",
    "created": "2026-02-12T03:19:38.168Z",
    "modified": "2026-02-12T03:32:31.121Z"
  }
]
